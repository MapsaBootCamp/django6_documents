## هدف
##### یک الگوی طراحی رفتاری است که به شما امکان می دهد بدون فاش کردن جزئیات اجرای آن، وضعیت قبلی یک شی را ذخیره و بازیابی کنید.

## مشکل
##### تصور کنید که در حال ایجاد یک برنامه ویرایشگر متن هستید. علاوه بر ویرایش ساده متن، ویرایشگر شما می تواند متن را قالب بندی کند، تصاویر درون خطی را وارد کند و غیره.

در برخی موارد، شما تصمیم گرفتید به کاربران اجازه دهید هر گونه عملیات انجام شده روی متن را لغو کنند. این ویژگی در طول سال ها به قدری رایج شده است که امروزه مردم انتظار دارند هر اپلیکیشنی آن را داشته باشد. برای اجرا، شما رویکرد مستقیم را انتخاب کردید. قبل از انجام هر عملیاتی، برنامه وضعیت همه اشیاء را ثبت می کند و آن را در مقداری حافظه ذخیره می کند. بعداً، وقتی کاربر تصمیم می‌گیرد یک عمل را برگرداند، برنامه آخرین عکس فوری را از تاریخچه دریافت می‌کند و از آن برای بازیابی وضعیت همه اشیا استفاده می‌کند.

احتمالاً باید تمام فیلدهای یک شی را مرور کنید و مقادیر آنها را در حافظه کپی کنید. با این حال، این تنها در صورتی کار می‌کند که شی محدودیت‌های دسترسی کاملاً راحت به محتویات خود داشته باشد. متأسفانه، بیشتر اشیاء واقعی به دیگران اجازه نمی‌دهند که به این راحتی درون آنها نگاه کنند و همه داده‌های مهم را در زمینه‌های خصوصی پنهان می‌کنند.

فعلاً این مشکل را نادیده بگیرید و بیایید فرض کنیم که اشیاء ما مانند هیپی ها رفتار می کنند: ترجیح دادن روابط باز و عمومی نگه داشتن وضعیت آنها. در حالی که این رویکرد مشکل فوری را حل می‌کند و به شما امکان می‌دهد عکس‌های فوری از حالات اشیاء را به دلخواه تهیه کنید، اما هنوز مشکلات جدی دارد. در آینده، ممکن است تصمیم بگیرید که برخی از کلاس‌های ویرایشگر را اصلاح کنید، یا برخی از فیلدها را اضافه یا حذف کنید. آسان به نظر می رسد، اما این امر همچنین مستلزم تغییر کلاس هایی است که مسئول کپی کردن وضعیت اشیاء آسیب دیده هستند.

اما موارد بیشتری وجود دارد. بیایید «تصاویر فوری» واقعی وضعیت سردبیر را در نظر بگیریم. شامل چه داده هایی است؟ حداقل باید حاوی متن واقعی، مختصات مکان نما، موقعیت اسکرول فعلی و غیره باشد. برای ایجاد یک عکس فوری، باید این مقادیر را جمع آوری کرده و در نوعی ظرف قرار دهید.

به احتمال زیاد، شما می خواهید تعداد زیادی از این اشیاء ظرف را در فهرستی ذخیره کنید که تاریخچه را نشان می دهد. بنابراین کانتینرها احتمالاً به اشیاء یک کلاس تبدیل می شوند. کلاس تقریباً هیچ روشی ندارد، اما فیلدهای زیادی دارد که وضعیت ویرایشگر را منعکس می کند. برای اجازه دادن به اشیاء دیگر برای نوشتن و خواندن داده ها از یک عکس فوری، احتمالاً باید فیلدهای آن را عمومی کنید. این همه حالت های سردبیر، خصوصی یا غیر خصوصی را فاش می کند. کلاس‌های دیگر به هر تغییر کوچکی در کلاس snapshot وابسته می‌شوند، که در غیر این صورت در فیلدها و روش‌های خصوصی بدون تأثیر بر کلاس‌های بیرونی اتفاق می‌افتد.

به نظر می‌رسد به بن‌بست رسیده‌ایم: شما یا تمام جزئیات داخلی کلاس‌ها را در معرض دید قرار می‌دهید، آنها را بیش از حد شکننده می‌کنید، یا دسترسی به وضعیت آنها را محدود می‌کنید و تولید عکس‌های فوری را غیرممکن می‌کنید. آیا راه دیگری برای اجرای "لغو" وجود دارد؟

## راه حل
همه مشکلاتی که ما به تازگی تجربه کرده ایم ناشی از کپسولاسیون شکسته است. برخی از اشیا سعی می کنند بیش از آنچه که قرار است انجام دهند. برای جمع‌آوری داده‌های مورد نیاز برای انجام برخی اقدامات، به جای اینکه به این اشیا اجازه دهند عمل واقعی را انجام دهند، به فضای خصوصی اشیاء دیگر حمله می‌کنند.

الگوی Memento ایجاد عکس‌های فوری حالت را به مالک واقعی آن حالت، یعنی شی مبتکر، واگذار می‌کند. از این رو، به جای اینکه اشیاء دیگری سعی کنند وضعیت ویرایشگر را از "خارج" کپی کنند، خود کلاس ویرایشگر می تواند عکس فوری را ایجاد کند زیرا دسترسی کامل به وضعیت خود دارد.

این الگو نشان می دهد که کپی وضعیت جسم در یک شی خاص به نام یادگاری ذخیره شود. محتویات یادگاری برای هیچ شیء دیگری غیر از چیزی که آن را تولید کرده است قابل دسترسی نیست. سایر اشیاء باید با استفاده از یک رابط محدود با یادگاری ارتباط برقرار کنند که ممکن است امکان واکشی فراداده عکس فوری (زمان ایجاد، نام عملیات انجام شده، و غیره) را فراهم کند، اما وضعیت شی اصلی موجود در عکس فوری را ندارد.[مدل کار کرد](https://refactoring.guru/images/patterns/diagrams/memento/solution-en.png)

چنین خط مشی محدود کننده ای به شما امکان می دهد یادگاری ها را در داخل اشیاء دیگر که معمولاً مراقب نامیده می شوند ذخیره کنید. از آنجایی که مراقب فقط از طریق رابط محدود با یادگاری کار می کند، نمی تواند وضعیت ذخیره شده در یادگاری را دستکاری کند. در عین حال، مبتکر به تمام فیلدهای داخل یادگاری دسترسی دارد و به آن اجازه می‌دهد تا به میل خود حالت قبلی خود را بازگرداند.

در مثال ویرایشگر متن خود، می‌توانیم یک کلاس تاریخ جداگانه ایجاد کنیم تا به عنوان مراقب عمل کند. هر بار که ویرایشگر قصد دارد عملیاتی را اجرا کند، یک پشته از یادگاری‌های ذخیره شده در داخل نگهدارنده افزایش می‌یابد. حتی می‌توانید این پشته را در رابط کاربری برنامه رندر کنید و تاریخچه عملیات‌های انجام شده قبلی را برای کاربر نمایش دهید.

هنگامی که کاربر واگرد را راه اندازی می کند، تاریخچه جدیدترین یادگاری را از پشته می گیرد و آن را به ویرایشگر ارسال می کند و درخواست بازگشت دارد. از آنجایی که ویرایشگر دسترسی کامل به یادگاری دارد، وضعیت خود را با مقادیر گرفته شده از یادگاری تغییر می دهد.

## ساختار
#### [پیاده سازی بر اساس کلاس های تو در تو](https://refactoring.guru/images/patterns/diagrams/memento/structure1-indexed.png)
پیاده‌سازی کلاسیک الگو به پشتیبانی از کلاس‌های تودرتو، که در بسیاری از زبان‌های برنامه‌نویسی محبوب (مانند C++، C# و جاوا) در دسترس است، متکی است.

کلاس Originator می تواند از حالت خود عکس های فوری تولید کند و همچنین در صورت نیاز حالت خود را از عکس های فوری بازیابی کند.

((ممنتو)) یک شی ارزشی است که به عنوان یک عکس فوری از وضعیت مبتکر عمل می کند. این یک روش معمول است که یادگاری را تغییرناپذیر کنیم و داده ها را فقط یک بار از طریق سازنده ارسال کنیم.

سرایدار نه تنها «چه زمانی» و «چرا» را می‌داند که وضعیت مبتکر را تصرف کند، بلکه همچنین می‌داند که چه زمانی باید وضعیت را بازیابی کند.
یک سرایدار می‌تواند با ذخیره کردن مجموعه‌ای از یادگاری‌ها، تاریخچه مبتکر را پیگیری کند. هنگامی که مبتکر باید به تاریخ سفر کند، مراقب بالاترین یادگاری را از پشته می‌آورد و آن را به روش بازسازی مبتکر منتقل می‌کند.

در این پیاده سازی، کلاس memento در داخل مبدا قرار می گیرد. این به سازنده اجازه می‌دهد به فیلدها و روش‌های یادگاری دسترسی داشته باشد، حتی اگر آنها خصوصی اعلام شده باشند. از سوی دیگر، نگهدار دسترسی بسیار محدودی به فیلدها و روش‌های یادگاری دارد، که به او اجازه می‌دهد یادگاری‌ها را در یک پشته ذخیره کند، اما وضعیت آنها را دستکاری نکند.

#### [پیاده سازی بر اساس یک رابط میانی](https://refactoring.guru/images/patterns/diagrams/memento/structure2-indexed.png)

یک پیاده سازی جایگزین وجود دارد، مناسب برای زبان های برنامه نویسی که از کلاس های تودرتو پشتیبانی نمی کنند (آره، PHP، من در مورد شما صحبت می کنم).

در غیاب کلاس‌های تودرتو، می‌توانید دسترسی به فیلدهای یادگاری را با ایجاد قراردادی محدود کنید که مراقبان می‌توانند با یک یادگاری فقط از طریق یک رابط واسط به‌صراحت اعلام‌شده کار کنند، که فقط روش‌های مرتبط با فراداده یادگاری را اعلام می‌کند.

از طرف دیگر، مبتکرها می توانند مستقیماً با یک شی memento کار کنند و به فیلدها و متدهای اعلام شده در کلاس memento دسترسی داشته باشند. نقطه ضعف این رویکرد این است که شما باید همه اعضای یادگاری را عمومی کنید.

#### [پیاده سازی با کپسوله سازی حتی سخت تر](https://refactoring.guru/images/patterns/diagrams/memento/structure3-indexed.png)

پیاده‌سازی دیگری وجود دارد که زمانی مفید است که نمی‌خواهید حتی کوچکترین شانسی را برای دسترسی کلاس‌های دیگر به وضعیت مبدأ از طریق یادگاری باقی بگذارید.

این پیاده سازی امکان داشتن انواع مختلفی از مبتکرها و یادگاری ها را فراهم می کند. هر سازنده با یک کلاس یادگاری مربوطه کار می کند. نه مبتکران و نه یادگارها وضعیت خود را در معرض دید کسی قرار نمی دهند.

مراقبین اکنون به صراحت از تغییر وضعیت ذخیره شده در یادگاری ها محدود شده اند. علاوه بر این، کلاس مراقبت از مبدأ مستقل می شود زیرا روش بازسازی اکنون در کلاس memento تعریف شده است.

هر یادگاری به سازنده ای که آن را تولید کرده است مرتبط می شود. مبتکر خود را به همراه مقادیر حالت آن به سازنده یادگار می‌دهد. به لطف ارتباط نزدیک بین این کلاس‌ها، یک یادگاری می‌تواند وضعیت مبتکر خود را بازیابی کند، با توجه به اینکه دومی تنظیم‌کننده‌های مناسب را تعریف کرده است.

