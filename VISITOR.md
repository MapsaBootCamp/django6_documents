## هدف

##### Visitor یک الگوی طراحی از نوع رفتاری است که به ما امکان می دهد الگوریتم های طراحی را از اشیایی که روی آنها کار می کنند جدا کنیم..


## مشکل

تصور کنید که تیم شما برنامه‌ای را توسعه می‌دهد که با اطلاعات جغرافیایی ساختار یافته به عنوان یک نمودار بزرگ کار می‌کند. هر گره از نمودار ممکن است یک موجودیت پیچیده مانند یک شهر را نشان دهد، اما همچنین چیزهای مهم تری مانند صنایع، مناطق دیدنی و غیره را نیز نشان می‌دهد. گره‌ها در صورتی که مسیری بین اشیاء واقعی وجود داشته باشد، به گره‌های دیگر متصل می‌شوند. در زیر هود، هر نوع گره با کلاس خود نشان داده می شود، در حالی که هر گره خاص یک شی است.
در برخی موارد، شما وظیفه ای برای پیاده سازی استخراج نمودار به فرمت اکسل دارید. در ابتدا، کار بسیار ساده به نظر می رسید. شما برنامه ریزی کرده اید که یک متد استخراجی را به هر کلاس گره اضافه کنید و سپس از اهرم بازگشتی برای عبور از هر گره گراف استفاده کنید و روش استخراج را اجرا کنید. راه حل ساده و ظریف بود: به لطف چندشکلی، شما کدی را که روش استخراج نامیده می‌شود با کلاس‌های کانکریت گره‌ها پیوند نمی‌دادید.

متأسفانه، معمار سیستم به شما اجازه تغییر کلاس‌های گره موجود را نداد. او گفت که این کد از قبل در حال تولید است و نمی‌خواهد به دلیل وجود اشکال احتمالی در تغییرات شما، خطر شکست آن را تهدید کند.
دلیل دیگری برای امتناع وجود داشت. بسیار محتمل بود که پس از اجرای این ویژگی، شخصی از بخش بازاریابی از شما بخواهد که امکان استخراج به فرمت دیگری را فراهم کنید یا چیزهای عجیب و غریب دیگری را درخواست کنید. این شما را مجبور می کند دوباره آن کلاس های گرانبها و شکننده را تغییر دهید.


## راه حل

الگوی بازدیدکننده پیشنهاد می‌کند که رفتار جدید را به جای تلاش برای ادغام آن در کلاس‌های موجود، در یک کلاس جداگانه به نام بازدیدکننده قرار دهید. شی اصلی که باید این رفتار را انجام می داد، اکنون به عنوان آرگومان به یکی از متدهای بازدیدکننده منتقل می شود و روش دسترسی به تمام داده های ضروری موجود در شی را فراهم می کند.

حال، اگر آن رفتار را بتوان روی اشیاء کلاس های مختلف اجرا کرد، چه؟ به عنوان مثال، در مورد ما با استخراج فایب بصورت اکسل، اجرای واقعی احتمالاً در کلاس‌های مختلف گره کمی متفاوت خواهد بود.

ممکن است بپرسید چرا از بارگذاری روش استفاده نمی کنیم؟ این زمانی است که به همه متدها یک نام می دهید، حتی اگر از مجموعه پارامترهای مختلفی پشتیبانی کنند. متأسفانه، حتی با فرض اینکه زبان برنامه نویسی ما اصلاً از آن پشتیبانی می کند (همانطور که جاوا و سی شارپ انجام می دهند)، به ما کمکی نخواهد کرد. از آنجایی که کلاس دقیق یک شی گره از قبل ناشناخته است، مکانیسم اضافه بار نمی تواند روش صحیح اجرا را تعیین کند.

با این حال، الگوی بازدید کننده این مشکل را برطرف می کند. از تکنیکی به نام( Double Dispatch )استفاده می کند که به اجرای روش مناسب بر روی یک شی بدون شرط های دست و پا گیر کمک می کند. به جای اینکه به مشتری اجازه دهیم نسخه مناسبی از متد را برای فراخوانی انتخاب کند، چطور این انتخاب را به اشیایی که به عنوان آرگومان به بازدیدکننده ارسال می کنیم، واگذار کنیم؟ از آنجایی که اشیا کلاس های خود را می شناسند، می توانند روش مناسبی را برای بازدیدکننده انتخاب کنند. آنها یک بازدیدکننده را "می پذیرند" و به او می گویند که چه روش بازدیدی باید اجرا شود.

یک نماینده باتجربه بیمه را تصور کنید که مشتاق به دست آوردن مشتریان جدید است. او می تواند از هر ساختمان در یک محله بازدید کند و سعی کند به هرکسی که ملاقات می کند بیمه بفروشد. بسته به نوع سازمانی که ساختمان را اشغال می کند، می تواند بیمه نامه های تخصصی ارائه دهد:

اگر ساختمان مسکونی باشد، بیمه درمانی می فروشد.
اگر بانک باشد، بیمه سرقت می فروشد.
اگر کافی شاپ باشد، بیمه آتش سوزی و سیل می فروشد.

## ساختار

https://refactoring.guru/images/patterns/diagrams/visitor/structure-en.png