
<div dir="rtl">

**بسم الله الرحمن الرحیم**

**دیزاین پترنState**

**دانشجو :‌علی مبینی فر**

کلیت : عموما این الگوی طراحی را میتوان نسخه داینامیکو پوسا الگوس استراتژی نامید و در دسته الگو های رفتاری جای داد . 
این الگو کاری میکند کهارتباطات بین کلاسها و موجودیت ها کنترل شود .رفتار این الگو به نحوی است که وقتی حالت داخلی یک شیی تغییر میکند با توجه به آن تغییر برنامه رفتار خود را تغییر میدهد و اینطور بنظر میرسد که شیی کلاس خود را تغییر داده است. این تغییر با فراخوانی حالتهای از پیش تعریف شده درون الگو اتفاق می افتد . 

بخش های مختلف این الگو در زیر آمده است  که بخش‌های مختلف آن هرکدام وظیفه و تعریفی دارند:

**Interface State**: این رابط کاربری برای متدهایی است که در هر کلاسِ state پیاده سازی می­شوند. این متد ها باید به گونه‌ای باشند که در هر کدام از کلاس‌های state، بتوانیم پیاده سازی درست و با معنی از آن‌ها داشته باشیم.

  **Context**: این کلاس یک شی از state را نگهداری می‌کند و یا به بیانی دیگر به یک state خاص اشاره می‌کند. و از طریق interface مربوط به state با شی state ارتباط برقرار می‌کند.

**Concrete States**: در بر گیرنده پیاده سازی براي متد هاي state می‌باشد. در واقع کلاس‌هایی هستند که حالت های خاص خود را از متدهایی که در interface اعلام شده است، پیاده سازی می‌کنند و در Context بر اساس شرایط مختلف، یکی از این کلاس‌های Concrete States اجرا خواهد شد.

اگر بخواهیم نحوه ی عملکرد این الگو را جزیی تر بررسی کنیم، ابتدا باید به کلاس Context دقت کنیم که یک متغیر از نوع State  را در خود دارد و این متغیر به یکی از شی های ساخته شده از کلاس‌های ConcreteStates اشاره می‌کند. در هر ConcreteStates متدهایی تعریف شده است (مثلا  doThisو doThat) که  این متدها بر اساس interfaceتعریف می‌شوند و همه ی عملیات لازم در هر State از طریق این متد ها انجام می‌شوند.

  کلاس Interface State  به داده‌های Context دسترسی کامل دارد. بنابراین در هر زمانی، هم کلاس Context و هم شی State می‌توانند تصمیم بگیرند که تغییر حالت بدهند. این کار با تغییر شی ذخیره شده state درContext  انجام می­شود. بعد از این تغییر state، همه ی درخواست ها به state جدید ارسال می‌شوند که ممکن است متدی که در این State انجام می‌شود با متد State قبلی کاملا رفتار متفاوتی داشته باشد.
  
  شرایط استفاده از الگوی طراحی **State**
از الگوی طراحی **state** در شرایط زیر استفاده می‌شود: 

·         پیاده سازی ابزارهای گرافیکی

·         اشیائی که با توجه به موقعیت فعلی ، رفتار کنند و در زمان اجرا تغییر کنند.

·         اشیائی که در حال پیچیده شدن هستند و شرط های زیادی دارند.

·         هنگامی که تعداد کدهای تکراری در حالت های مشابه زیاد شوند و انتقال state ها مبتنی بر شرایط باشد.



**مزایا و معایب استفاده از الگوی طراحی State**

مزایای استفاده از الگوی طراحی **State** می‌تواند موارد زیر باشد: 

1.      کد مربوط به state های خاص در کلاس‌های جداگانه سازماندهی می­شود . (Single Responsibility)

2.      حالت ها یا state های جدید، بدون تغییر در کلاس‌های State موجود یا Context معرفی می­شوند.(Open/Closed) در واقع این الگو پیشنهاد می‌کند همه­ی حالت های خاص کد را درون مجموعه ای از کلاس‌های مجزا قرار دهیم. در نتیجه می‌توانیم حالت جدیدی اضافه کنیم یا حالت های موجود را به طور مستقل از یکدیگر، تغییر دهیم و هزینه نگهداری را کاهش دهیم.

3.      کد کلاس Context را با حذف شرط­های حجیم ماشین state ساده می‌کند.

استفاده از الگوی طراحی **State** ممکن است دارای معایبی باشد:

·         اگر یک ماشین state فقط چند حالت داشته باشد یا به ندرت تغییر کند، استفاده از الگوی state باعث پیچیدگی بیشتر می­شود.


نمونه کد زیر از الگوی طراحی **state** میباشد :




<div dir="ltr">

import abc


class Context:
    """
    Define the interface of interest to clients.
    Maintain an instance of a ConcreteState subclass that defines the
    current state.
    """

    def __init__(self, state):
        self._state = state

    def request(self):
        self._state.handle()


class State(metaclass=abc.ABCMeta):
    """
    Define an interface for encapsulating the behavior associated with a
    particular state of the Context.
    """

    @abc.abstractmethod
    def handle(self):
        pass


class ConcreteStateA(State):
    """
    Implement a behavior associated with a state of the Context.
    """

    def handle(self):
        pass


class ConcreteStateB(State):
    """
    Implement a behavior associated with a state of the Context.
    """

    def handle(self):
        pass


def main():
    concrete_state_a = ConcreteStateA()
    context = Context(concrete_state_a)
    context.request()


if __name__ == "__main__":
    main()

